---
layout: post
---


```python
import keras
keras.__version__
```

    Using TensorFlow backend.
    /anaconda3/lib/python3.7/site-packages/tensorflow/python/framework/dtypes.py:526: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.
      _np_qint8 = np.dtype([("qint8", np.int8, 1)])
    /anaconda3/lib/python3.7/site-packages/tensorflow/python/framework/dtypes.py:527: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.
      _np_quint8 = np.dtype([("quint8", np.uint8, 1)])
    /anaconda3/lib/python3.7/site-packages/tensorflow/python/framework/dtypes.py:528: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.
      _np_qint16 = np.dtype([("qint16", np.int16, 1)])
    /anaconda3/lib/python3.7/site-packages/tensorflow/python/framework/dtypes.py:529: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.
      _np_quint16 = np.dtype([("quint16", np.uint16, 1)])
    /anaconda3/lib/python3.7/site-packages/tensorflow/python/framework/dtypes.py:530: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.
      _np_qint32 = np.dtype([("qint32", np.int32, 1)])
    /anaconda3/lib/python3.7/site-packages/tensorflow/python/framework/dtypes.py:535: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.
      np_resource = np.dtype([("resource", np.ubyte, 1)])





    '2.3.1'



# 5.2 - Using convnets with small datasets

This notebook contains the code sample found in Chapter 5, Section 2 of [Deep Learning with Python](https://www.manning.com/books/deep-learning-with-python?a_aid=keras&a_bid=76564dff). Note that the original text features far more content, in particular further explanations and figures: in this notebook, you will only find source code and related comments.

## Training a convnet from scratch on a small dataset

Having to train an image classification model using only very little data is a common situation, which you likely encounter yourself in 
practice if you ever do computer vision in a professional context.

Having "few" samples can mean anywhere from a few hundreds to a few tens of thousands of images. As a practical example, we will focus on 
classifying images as "dogs" or "cats", in a dataset containing 4000 pictures of cats and dogs (2000 cats, 2000 dogs). We will use 2000 
pictures for training, 1000 for validation, and finally 1000 for testing.

In this section, we will review one basic strategy to tackle this problem: training a new model from scratch on what little data we have. We 
will start by naively training a small convnet on our 2000 training samples, without any regularization, to set a baseline for what can be 
achieved. This will get us to a classification accuracy of 71%. At that point, our main issue will be overfitting. Then we will introduce 
*data augmentation*, a powerful technique for mitigating overfitting in computer vision. By leveraging data augmentation, we will improve 
our network to reach an accuracy of 82%.

In the next section, we will review two more essential techniques for applying deep learning to small datasets: *doing feature extraction 
with a pre-trained network* (this will get us to an accuracy of 90% to 93%), and *fine-tuning a pre-trained network* (this will get us to 
our final accuracy of 95%). Together, these three strategies -- training a small model from scratch, doing feature extracting using a 
pre-trained model, and fine-tuning a pre-trained model -- will constitute your future toolbox for tackling the problem of doing computer 
vision with small datasets.

## The relevance of deep learning for small-data problems

You will sometimes hear that deep learning only works when lots of data is available. This is in part a valid point: one fundamental 
characteristic of deep learning is that it is able to find interesting features in the training data on its own, without any need for manual 
feature engineering, and this can only be achieved when lots of training examples are available. This is especially true for problems where 
the input samples are very high-dimensional, like images.

However, what constitutes "lots" of samples is relative -- relative to the size and depth of the network you are trying to train, for 
starters. It isn't possible to train a convnet to solve a complex problem with just a few tens of samples, but a few hundreds can 
potentially suffice if the model is small and well-regularized and if the task is simple. 
Because convnets learn local, translation-invariant features, they are very 
data-efficient on perceptual problems. Training a convnet from scratch on a very small image dataset will still yield reasonable results 
despite a relative lack of data, without the need for any custom feature engineering. You will see this in action in this section.

But what's more, deep learning models are by nature highly repurposable: you can take, say, an image classification or speech-to-text model 
trained on a large-scale dataset then reuse it on a significantly different problem with only minor changes. Specifically, in the case of 
computer vision, many pre-trained models (usually trained on the ImageNet dataset) are now publicly available for download and can be used 
to bootstrap powerful vision models out of very little data. That's what we will do in the next section.

For now, let's get started by getting our hands on the data.

## Downloading the data

The cats vs. dogs dataset that we will use isn't packaged with Keras. It was made available by Kaggle.com as part of a computer vision 
competition in late 2013, back when convnets weren't quite mainstream. You can download the original dataset at: 
`https://www.kaggle.com/c/dogs-vs-cats/data` (you will need to create a Kaggle account if you don't already have one -- don't worry, the 
process is painless).

The pictures are medium-resolution color JPEGs. They look like this:

![cats_vs_dogs_samples](https://s3.amazonaws.com/book.keras.io/img/ch5/cats_vs_dogs_samples.jpg)

Unsurprisingly, the cats vs. dogs Kaggle competition in 2013 was won by entrants who used convnets. The best entries could achieve up to 
95% accuracy. In our own example, we will get fairly close to this accuracy (in the next section), even though we will be training our 
models on less than 10% of the data that was available to the competitors.
This original dataset contains 25,000 images of dogs and cats (12,500 from each class) and is 543MB large (compressed). After downloading 
and uncompressing it, we will create a new dataset containing three subsets: a training set with 1000 samples of each class, a validation 
set with 500 samples of each class, and finally a test set with 500 samples of each class.

Here are a few lines of code to do this:


```python
import os, shutil
```


```python
os.getcwd()
```




    '/home/jupyter-loecher'




```python
## DO NOT EXECUTE !!

# The path to the directory where the original
# dataset was uncompressed
original_dataset_dir = '/home/loecher/data/train/'

# The directory where we will
# store our smaller dataset
base_dir = '/home/loecher/data/cats_and_dogs'
os.mkdir(base_dir)

# Directories for our training,
# validation and test splits
train_dir = os.path.join(base_dir, 'train')
os.mkdir(train_dir)
validation_dir = os.path.join(base_dir, 'validation')
os.mkdir(validation_dir)
test_dir = os.path.join(base_dir, 'test')
os.mkdir(test_dir)

# Directory with our training cat pictures
train_cats_dir = os.path.join(train_dir, 'cats')
os.mkdir(train_cats_dir)

# Directory with our training dog pictures
train_dogs_dir = os.path.join(train_dir, 'dogs')
os.mkdir(train_dogs_dir)

# Directory with our validation cat pictures
validation_cats_dir = os.path.join(validation_dir, 'cats')
os.mkdir(validation_cats_dir)

# Directory with our validation dog pictures
validation_dogs_dir = os.path.join(validation_dir, 'dogs')
os.mkdir(validation_dogs_dir)

# Directory with our validation cat pictures
test_cats_dir = os.path.join(test_dir, 'cats')
os.mkdir(test_cats_dir)

# Directory with our validation dog pictures
test_dogs_dir = os.path.join(test_dir, 'dogs')
os.mkdir(test_dogs_dir)

# Copy first 1000 cat images to train_cats_dir
fnames = ['cat.{}.jpg'.format(i) for i in range(1000)]
for fname in fnames:
    src = os.path.join(original_dataset_dir, fname)
    dst = os.path.join(train_cats_dir, fname)
    shutil.copyfile(src, dst)

# Copy next 500 cat images to validation_cats_dir
fnames = ['cat.{}.jpg'.format(i) for i in range(1000, 1500)]
for fname in fnames:
    src = os.path.join(original_dataset_dir, fname)
    dst = os.path.join(validation_cats_dir, fname)
    shutil.copyfile(src, dst)
    
# Copy next 500 cat images to test_cats_dir
fnames = ['cat.{}.jpg'.format(i) for i in range(1500, 2000)]
for fname in fnames:
    src = os.path.join(original_dataset_dir, fname)
    dst = os.path.join(test_cats_dir, fname)
    shutil.copyfile(src, dst)
    
# Copy first 1000 dog images to train_dogs_dir
fnames = ['dog.{}.jpg'.format(i) for i in range(1000)]
for fname in fnames:
    src = os.path.join(original_dataset_dir, fname)
    dst = os.path.join(train_dogs_dir, fname)
    shutil.copyfile(src, dst)
    
# Copy next 500 dog images to validation_dogs_dir
fnames = ['dog.{}.jpg'.format(i) for i in range(1000, 1500)]
for fname in fnames:
    src = os.path.join(original_dataset_dir, fname)
    dst = os.path.join(validation_dogs_dir, fname)
    shutil.copyfile(src, dst)
    
# Copy next 500 dog images to test_dogs_dir
fnames = ['dog.{}.jpg'.format(i) for i in range(1500, 2000)]
for fname in fnames:
    src = os.path.join(original_dataset_dir, fname)
    dst = os.path.join(test_dogs_dir, fname)
    shutil.copyfile(src, dst)
```

From 
https://colab.research.google.com/github/google/eng-edu/blob/master/ml/pc/exercises/image_classification_part1.ipynb



```python
#!wget --no-check-certificate \
#    https://storage.googleapis.com/mledu-datasets/cats_and_dogs_filtered.zip \
#    -O /tmp/cats_and_dogs_filtered.zip

import os
import zipfile

local_zip = '/tmp/cats_and_dogs_filtered.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/tmp')
zip_ref.close()

base_dir = '/tmp/cats_and_dogs_filtered'
train_dir = os.path.join(base_dir, 'train')
validation_dir = os.path.join(base_dir, 'validation')

# Directory with our training cat pictures
train_cats_dir = os.path.join(train_dir, 'cats')

# Directory with our training dog pictures
train_dogs_dir = os.path.join(train_dir, 'dogs')

# Directory with our validation cat pictures
validation_cats_dir = os.path.join(validation_dir, 'cats')

# Directory with our validation dog pictures
validation_dogs_dir = os.path.join(validation_dir, 'dogs')
```

Now, let's see what the filenames look like in the cats and dogs train directories (file naming conventions are the same in the validation directory):


```python
train_cat_fnames = os.listdir(train_cats_dir)
print(train_cat_fnames[:10])

train_dog_fnames = os.listdir(train_dogs_dir)
train_dog_fnames.sort()
print (train_dog_fnames[:10])
```

As a sanity check, let's count how many pictures we have in each training split (train/validation/test):


```python
print('total training cat images:', len(os.listdir(train_cats_dir)))
```

    total training cat images: 1000



```python
print('total training dog images:', len(os.listdir(train_dogs_dir)))
```

    total training dog images: 1000



```python
print('total validation cat images:', len(os.listdir(validation_cats_dir)))
```

    total validation cat images: 500



```python
print('total validation dog images:', len(os.listdir(validation_dogs_dir)))
```

    total validation dog images: 500



```python
print('total test cat images:', len(os.listdir(test_cats_dir)))
```

    total test cat images: 500



```python
print('total test dog images:', len(os.listdir(test_dogs_dir)))
```

    total test dog images: 500



So we have indeed 2000 training images, and then 1000 validation images and 1000 test images. In each split, there is the same number of 
samples from each class: this is a balanced binary classification problem, which means that classification accuracy will be an appropriate 
measure of success.

## Building our network

We've already built a small convnet for MNIST in the previous example, so you should be familiar with them. We will reuse the same 
general structure: our convnet will be a stack of alternated `Conv2D` (with `relu` activation) and `MaxPooling2D` layers.

However, since we are dealing with bigger images and a more complex problem, we will make our network accordingly larger: it will have one 
more `Conv2D` + `MaxPooling2D` stage. This serves both to augment the capacity of the network, and to further reduce the size of the 
feature maps, so that they aren't overly large when we reach the `Flatten` layer. Here, since we start from inputs of size 150x150 (a 
somewhat arbitrary choice), we end up with feature maps of size 7x7 right before the `Flatten` layer.

Note that the depth of the feature maps is progressively increasing in the network (from 32 to 128), while the size of the feature maps is 
decreasing (from 148x148 to 7x7). This is a pattern that you will see in almost all convnets.

Since we are attacking a binary classification problem, we are ending the network with a single unit (a `Dense` layer of size 1) and a 
`sigmoid` activation. This unit will encode the probability that the network is looking at one class or the other.


```python
from keras import layers
from keras import models

model = models.Sequential()
model.add(layers.Conv2D(32, (3, 3), activation='relu',
                        input_shape=(150, 150, 3)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(128, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(128, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Flatten())
model.add(layers.Dense(512, activation='relu'))
model.add(layers.Dense(1, activation='sigmoid'))
```

Let's take a look at how the dimensions of the feature maps change with every successive layer:


```python
model.summary()
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-1-5f15418b3570> in <module>
    ----> 1 model.summary()
    

    NameError: name 'model' is not defined


For our compilation step, we'll go with the `RMSprop` optimizer as usual. Since we ended our network with a single sigmoid unit, we will 
use binary crossentropy as our loss (as a reminder, check out the table in Chapter 4, section 5 for a cheatsheet on what loss function to 
use in various situations).


```python
from keras import optimizers

model.compile(loss='binary_crossentropy',
              optimizer=optimizers.RMSprop(lr=1e-4),
              metrics=['acc'])
```

## Data preprocessing

As you already know by now, data should be formatted into appropriately pre-processed floating point tensors before being fed into our 
network. Currently, our data sits on a drive as JPEG files, so the steps for getting it into our network are roughly:

* Read the picture files.
* Decode the JPEG content to RBG grids of pixels.
* Convert these into floating point tensors.
* Rescale the pixel values (between 0 and 255) to the [0, 1] interval (as you know, neural networks prefer to deal with small input values).

It may seem a bit daunting, but thankfully Keras has utilities to take care of these steps automatically. Keras has a module with image 
processing helper tools, located at `keras.preprocessing.image`. In particular, it contains the class `ImageDataGenerator` which allows to 
quickly set up Python generators that can automatically turn image files on disk into batches of pre-processed tensors. This is what we 
will use here.


```python
from keras.preprocessing.image import ImageDataGenerator

# All images will be rescaled by 1./255
train_datagen = ImageDataGenerator(rescale=1./255)
test_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_directory(
        # This is the target directory
        train_dir,
        # All images will be resized to 150x150
        target_size=(150, 150),
        batch_size=20,
        # Since we use binary_crossentropy loss, we need binary labels
        class_mode='binary')

validation_generator = test_datagen.flow_from_directory(
        validation_dir,
        target_size=(150, 150),
        batch_size=20,
        class_mode='binary')
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-16-3f364d5f4e9d> in <module>
          7 train_generator = train_datagen.flow_from_directory(
          8         # This is the target directory
    ----> 9         train_dir,
         10         # All images will be resized to 150x150
         11         target_size=(150, 150),


    NameError: name 'train_dir' is not defined


Let's take a look at the output of one of these generators: it yields batches of 150x150 RGB images (shape `(20, 150, 150, 3)`) and binary 
labels (shape `(20,)`). 20 is the number of samples in each batch (the batch size). Note that the generator yields these batches 
indefinitely: it just loops endlessly over the images present in the target folder. For this reason, we need to `break` the iteration loop 
at some point.


```python
for data_batch, labels_batch in train_generator:
    print('data batch shape:', data_batch.shape)
    print('labels batch shape:', labels_batch.shape)
    break
```

Let's fit our model to the data using the generator. We do it using the `fit_generator` method, the equivalent of `fit` for data generators 
like ours. It expects as first argument a Python generator that will yield batches of inputs and targets indefinitely, like ours does. 
Because the data is being generated endlessly, the generator needs to know example how many samples to draw from the generator before 
declaring an epoch over. This is the role of the `steps_per_epoch` argument: after having drawn `steps_per_epoch` batches from the 
generator, i.e. after having run for `steps_per_epoch` gradient descent steps, the fitting process will go to the next epoch. In our case, 
batches are 20-sample large, so it will take 100 batches until we see our target of 2000 samples.

When using `fit_generator`, one may pass a `validation_data` argument, much like with the `fit` method. Importantly, this argument is 
allowed to be a data generator itself, but it could be a tuple of Numpy arrays as well. If you pass a generator as `validation_data`, then 
this generator is expected to yield batches of validation data endlessly, and thus you should also specify the `validation_steps` argument, 
which tells the process how many batches to draw from the validation generator for evaluation.


```python
history = model.fit_generator(
      train_generator,
      steps_per_epoch=100,
      epochs=30,
      validation_data=validation_generator,
      validation_steps=50)
```

It is good practice to always save your models after training:


```python
model.save('cats_and_dogs_small_1.h5')
```

Let's plot the loss and accuracy of the model over the training and validation data during training:


```python
import matplotlib.pyplot as plt

acc = history.history['acc']
val_acc = history.history['val_acc']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(len(acc))

plt.plot(epochs, acc, 'bo', label='Training acc')
plt.plot(epochs, val_acc, 'b', label='Validation acc')
plt.title('Training and validation accuracy')
plt.legend()

plt.figure()

plt.plot(epochs, loss, 'bo', label='Training loss')
plt.plot(epochs, val_loss, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.legend()

plt.show()
```

These plots are characteristic of overfitting. Our training accuracy increases linearly over time, until it reaches nearly 100%, while our 
validation accuracy stalls at 70-72%. Our validation loss reaches its minimum after only five epochs then stalls, while the training loss 
keeps decreasing linearly until it reaches nearly 0.

Because we only have relatively few training samples (2000), overfitting is going to be our number one concern. You already know about a 
number of techniques that can help mitigate overfitting, such as dropout and weight decay (L2 regularization). We are now going to 
introduce a new one, specific to computer vision, and used almost universally when processing images with deep learning models: *data 
augmentation*.

## Using data augmentation

Overfitting is caused by having too few samples to learn from, rendering us unable to train a model able to generalize to new data. 
Given infinite data, our model would be exposed to every possible aspect of the data distribution at hand: we would never overfit. Data 
augmentation takes the approach of generating more training data from existing training samples, by "augmenting" the samples via a number 
of random transformations that yield believable-looking images. The goal is that at training time, our model would never see the exact same 
picture twice. This helps the model get exposed to more aspects of the data and generalize better.

In Keras, this can be done by configuring a number of random transformations to be performed on the images read by our `ImageDataGenerator` 
instance. Let's get started with an example:


```python
datagen = ImageDataGenerator(
      rotation_range=40,
      width_shift_range=0.2,
      height_shift_range=0.2,
      shear_range=0.2,
      zoom_range=0.2,
      horizontal_flip=True,
      fill_mode='nearest')
```

These are just a few of the options available (for more, see the Keras documentation). Let's quickly go over what we just wrote:

* `rotation_range` is a value in degrees (0-180), a range within which to randomly rotate pictures.
* `width_shift` and `height_shift` are ranges (as a fraction of total width or height) within which to randomly translate pictures 
vertically or horizontally.
* `shear_range` is for randomly applying shearing transformations.
* `zoom_range` is for randomly zooming inside pictures.
* `horizontal_flip` is for randomly flipping half of the images horizontally -- relevant when there are no assumptions of horizontal 
asymmetry (e.g. real-world pictures).
* `fill_mode` is the strategy used for filling in newly created pixels, which can appear after a rotation or a width/height shift.

Let's take a look at our augmented images:


```python
train_cats_dir = '/home/loecher/data/cats_and_dogs/train/cats'
```


```python
import matplotlib.pyplot as plt

# This is module with image preprocessing utilities
from keras.preprocessing import image

fnames = [os.path.join(train_cats_dir, fname) for fname in os.listdir(train_cats_dir)]

# We pick one image to "augment"
img_path = fnames[3]

# Read the image and resize it
img = image.load_img(img_path, target_size=(150, 150))

# Convert it to a Numpy array with shape (150, 150, 3)
x = image.img_to_array(img)

# Reshape it to (1, 150, 150, 3)
x = x.reshape((1,) + x.shape)

# The .flow() command below generates batches of randomly transformed images.
# It will loop indefinitely, so we need to `break` the loop at some point!
i = 0
for batch in datagen.flow(x, batch_size=1):
    plt.figure(i)
    imgplot = plt.imshow(image.array_to_img(batch[0]))
    #some_batches.append(batch[0])
    i += 1
    if i % 4 == 0: # Number of pictures printed
        break

plt.show()
```


![png](output_41_0.png)



![png](output_41_1.png)



![png](output_41_2.png)



![png](output_41_3.png)


If we train a new network using this data augmentation configuration, our network will never see twice the same input. However, the inputs 
that it sees are still heavily intercorrelated, since they come from a small number of original images -- we cannot produce new information, 
we can only remix existing information. As such, this might not be quite enough to completely get rid of overfitting. To further fight 
overfitting, we will also add a Dropout layer to our model, right before the densely-connected classifier:


```python
model = models.Sequential()
model.add(layers.Conv2D(64, (3, 3), activation='relu',
                        input_shape=(150, 150, 3))) # NOTE: 32 was changed to 64 to run the 5.4.2 code (due to 8x8)
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(128, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(128, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Flatten())
model.add(layers.Dropout(0.5))
model.add(layers.Dense(512, activation='relu'))
model.add(layers.Dense(1, activation='sigmoid'))

model.compile(loss='binary_crossentropy',
              optimizer=optimizers.RMSprop(lr=1e-4),
              metrics=['acc'])
```

Let's train our network using data augmentation and dropout:


```python
import time
```


```python
start_time = time.time()

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=40,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,)

# Note that the validation data should not be augmented!
test_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_directory(
        # This is the target directory
        train_dir,
        # All images will be resized to 150x150
        target_size=(150, 150),
        batch_size=32,
        # Since we use binary_crossentropy loss, we need binary labels
        class_mode='binary')

validation_generator = test_datagen.flow_from_directory(
        validation_dir,
        target_size=(150, 150),
        batch_size=32,
        class_mode='binary')

history = model.fit_generator(
      train_generator,
      steps_per_epoch=100,
      epochs=100,
      validation_data=validation_generator,
      validation_steps=50)

print("--- %s seconds ---" % (time.time() - start_time))
```

    Found 2000 images belonging to 2 classes.
    Found 1000 images belonging to 2 classes.
    Epoch 1/100
    100/100 [==============================] - 34s 340ms/step - loss: 0.6891 - acc: 0.5334 - val_loss: 0.6686 - val_acc: 0.5742
    Epoch 2/100
    100/100 [==============================] - 33s 334ms/step - loss: 0.6745 - acc: 0.5684 - val_loss: 0.6531 - val_acc: 0.6037
    Epoch 3/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.6500 - acc: 0.6144 - val_loss: 0.6305 - val_acc: 0.6307
    Epoch 4/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.6365 - acc: 0.6269 - val_loss: 0.6089 - val_acc: 0.6430
    Epoch 5/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.6134 - acc: 0.6650 - val_loss: 0.5935 - val_acc: 0.6701
    Epoch 6/100
    100/100 [==============================] - 33s 329ms/step - loss: 0.6007 - acc: 0.6669 - val_loss: 0.6074 - val_acc: 0.6643
    Epoch 7/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.5996 - acc: 0.6700 - val_loss: 0.5806 - val_acc: 0.6802
    Epoch 8/100
    100/100 [==============================] - 33s 330ms/step - loss: 0.5880 - acc: 0.6891 - val_loss: 0.5632 - val_acc: 0.7055
    Epoch 9/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.5814 - acc: 0.6753 - val_loss: 0.6103 - val_acc: 0.6604
    Epoch 10/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.5752 - acc: 0.6928 - val_loss: 0.5717 - val_acc: 0.6885
    Epoch 11/100
    100/100 [==============================] - 33s 325ms/step - loss: 0.5576 - acc: 0.7125 - val_loss: 0.5328 - val_acc: 0.7088
    Epoch 12/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.5655 - acc: 0.7013 - val_loss: 0.5697 - val_acc: 0.7011
    Epoch 13/100
    100/100 [==============================] - 33s 332ms/step - loss: 0.5611 - acc: 0.7037 - val_loss: 0.5686 - val_acc: 0.7120
    Epoch 14/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.5535 - acc: 0.7097 - val_loss: 0.5238 - val_acc: 0.7265
    Epoch 15/100
    100/100 [==============================] - 33s 334ms/step - loss: 0.5452 - acc: 0.7291 - val_loss: 0.5341 - val_acc: 0.7352
    Epoch 16/100
    100/100 [==============================] - 32s 325ms/step - loss: 0.5348 - acc: 0.7362 - val_loss: 0.5255 - val_acc: 0.7236
    Epoch 17/100
    100/100 [==============================] - 33s 325ms/step - loss: 0.5469 - acc: 0.7156 - val_loss: 0.5126 - val_acc: 0.7430
    Epoch 18/100
    100/100 [==============================] - 34s 337ms/step - loss: 0.5339 - acc: 0.7297 - val_loss: 0.5448 - val_acc: 0.7152
    Epoch 19/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.5224 - acc: 0.7259 - val_loss: 0.5645 - val_acc: 0.7005
    Epoch 20/100
    100/100 [==============================] - 34s 342ms/step - loss: 0.5251 - acc: 0.7337 - val_loss: 0.5010 - val_acc: 0.7448
    Epoch 21/100
    100/100 [==============================] - 38s 381ms/step - loss: 0.5171 - acc: 0.7459 - val_loss: 0.4821 - val_acc: 0.7557
    Epoch 22/100
    100/100 [==============================] - 37s 367ms/step - loss: 0.5159 - acc: 0.7484 - val_loss: 0.5188 - val_acc: 0.7474
    Epoch 23/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.5116 - acc: 0.7456 - val_loss: 0.5118 - val_acc: 0.7360
    Epoch 24/100
    100/100 [==============================] - 33s 331ms/step - loss: 0.5038 - acc: 0.7544 - val_loss: 0.4689 - val_acc: 0.7713
    Epoch 25/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.4966 - acc: 0.7528 - val_loss: 0.5264 - val_acc: 0.7371
    Epoch 26/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.5050 - acc: 0.7431 - val_loss: 0.5111 - val_acc: 0.7481
    Epoch 27/100
    100/100 [==============================] - 33s 334ms/step - loss: 0.5024 - acc: 0.7500 - val_loss: 0.6032 - val_acc: 0.6901
    Epoch 28/100
    100/100 [==============================] - 34s 343ms/step - loss: 0.5012 - acc: 0.7463 - val_loss: 0.5170 - val_acc: 0.7525
    Epoch 29/100
    100/100 [==============================] - 47s 466ms/step - loss: 0.4931 - acc: 0.7616 - val_loss: 0.5437 - val_acc: 0.7390
    Epoch 30/100
    100/100 [==============================] - 41s 414ms/step - loss: 0.4948 - acc: 0.7538 - val_loss: 0.4769 - val_acc: 0.7773
    Epoch 31/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.4832 - acc: 0.7634 - val_loss: 0.5248 - val_acc: 0.7397
    Epoch 32/100
    100/100 [==============================] - 32s 325ms/step - loss: 0.4895 - acc: 0.7612 - val_loss: 0.4857 - val_acc: 0.7661
    Epoch 33/100
    100/100 [==============================] - 32s 322ms/step - loss: 0.4746 - acc: 0.7719 - val_loss: 0.4984 - val_acc: 0.7633
    Epoch 34/100
    100/100 [==============================] - 33s 331ms/step - loss: 0.4820 - acc: 0.7572 - val_loss: 0.4754 - val_acc: 0.7577
    Epoch 35/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.4766 - acc: 0.7734 - val_loss: 0.4488 - val_acc: 0.7843
    Epoch 36/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.4673 - acc: 0.7709 - val_loss: 0.5524 - val_acc: 0.7365
    Epoch 37/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.4664 - acc: 0.7728 - val_loss: 0.5555 - val_acc: 0.7367
    Epoch 38/100
    100/100 [==============================] - 33s 331ms/step - loss: 0.4708 - acc: 0.7731 - val_loss: 0.4921 - val_acc: 0.7519
    Epoch 39/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.4574 - acc: 0.7844 - val_loss: 0.4485 - val_acc: 0.7811
    Epoch 40/100
    100/100 [==============================] - 33s 332ms/step - loss: 0.4603 - acc: 0.7841 - val_loss: 0.4790 - val_acc: 0.7706
    Epoch 41/100
    100/100 [==============================] - 33s 329ms/step - loss: 0.4708 - acc: 0.7866 - val_loss: 0.4591 - val_acc: 0.7867
    Epoch 42/100
    100/100 [==============================] - 33s 326ms/step - loss: 0.4608 - acc: 0.7819 - val_loss: 0.4237 - val_acc: 0.8020
    Epoch 43/100
    100/100 [==============================] - 33s 330ms/step - loss: 0.4451 - acc: 0.7940 - val_loss: 0.4649 - val_acc: 0.7719
    Epoch 44/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.4483 - acc: 0.7850 - val_loss: 0.4626 - val_acc: 0.7728
    Epoch 45/100
    100/100 [==============================] - 33s 329ms/step - loss: 0.4415 - acc: 0.7912 - val_loss: 0.4742 - val_acc: 0.7674
    Epoch 46/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.4508 - acc: 0.7863 - val_loss: 0.4311 - val_acc: 0.7862
    Epoch 47/100
    100/100 [==============================] - 33s 329ms/step - loss: 0.4365 - acc: 0.7866 - val_loss: 0.4551 - val_acc: 0.7861
    Epoch 48/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.4433 - acc: 0.7912 - val_loss: 0.4693 - val_acc: 0.7784
    Epoch 49/100
    100/100 [==============================] - 32s 325ms/step - loss: 0.4396 - acc: 0.7913 - val_loss: 0.4819 - val_acc: 0.7659
    Epoch 50/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.4346 - acc: 0.7962 - val_loss: 0.5620 - val_acc: 0.7603
    Epoch 51/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.4332 - acc: 0.7981 - val_loss: 0.4355 - val_acc: 0.7944
    Epoch 52/100
    100/100 [==============================] - 34s 339ms/step - loss: 0.4211 - acc: 0.8031 - val_loss: 0.4864 - val_acc: 0.7635
    Epoch 53/100
    100/100 [==============================] - 33s 326ms/step - loss: 0.4140 - acc: 0.8066 - val_loss: 0.4894 - val_acc: 0.7747
    Epoch 54/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.4220 - acc: 0.8016 - val_loss: 0.4838 - val_acc: 0.7693
    Epoch 55/100
    100/100 [==============================] - 32s 325ms/step - loss: 0.4253 - acc: 0.8037 - val_loss: 0.4664 - val_acc: 0.7665
    Epoch 56/100
    100/100 [==============================] - 33s 333ms/step - loss: 0.4271 - acc: 0.8013 - val_loss: 0.4370 - val_acc: 0.8041
    Epoch 57/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.4196 - acc: 0.8013 - val_loss: 0.4442 - val_acc: 0.7932
    Epoch 58/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.4070 - acc: 0.8159 - val_loss: 0.4250 - val_acc: 0.8046
    Epoch 59/100
    100/100 [==============================] - 33s 332ms/step - loss: 0.4175 - acc: 0.8066 - val_loss: 0.4358 - val_acc: 0.7912
    Epoch 60/100
    100/100 [==============================] - 33s 325ms/step - loss: 0.4192 - acc: 0.8087 - val_loss: 0.4929 - val_acc: 0.7627
    Epoch 61/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.4039 - acc: 0.8150 - val_loss: 0.4358 - val_acc: 0.7996
    Epoch 62/100
    100/100 [==============================] - 33s 326ms/step - loss: 0.4106 - acc: 0.8100 - val_loss: 0.4423 - val_acc: 0.7995
    Epoch 63/100
    100/100 [==============================] - 33s 334ms/step - loss: 0.4015 - acc: 0.8141 - val_loss: 0.4223 - val_acc: 0.8093
    Epoch 64/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.4045 - acc: 0.8147 - val_loss: 0.4287 - val_acc: 0.8028
    Epoch 65/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.3957 - acc: 0.8131 - val_loss: 0.4439 - val_acc: 0.8014
    Epoch 66/100
    100/100 [==============================] - 33s 330ms/step - loss: 0.4011 - acc: 0.8184 - val_loss: 0.5133 - val_acc: 0.7945
    Epoch 67/100
    100/100 [==============================] - 32s 320ms/step - loss: 0.3911 - acc: 0.8197 - val_loss: 0.4677 - val_acc: 0.7938
    Epoch 68/100
    100/100 [==============================] - 33s 331ms/step - loss: 0.3986 - acc: 0.8266 - val_loss: 0.4554 - val_acc: 0.8035
    Epoch 69/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.3822 - acc: 0.8291 - val_loss: 0.4739 - val_acc: 0.7906
    Epoch 70/100
    100/100 [==============================] - 33s 329ms/step - loss: 0.3907 - acc: 0.8206 - val_loss: 0.4225 - val_acc: 0.8196
    Epoch 71/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.3875 - acc: 0.8278 - val_loss: 0.4572 - val_acc: 0.8122
    Epoch 72/100
    100/100 [==============================] - 33s 331ms/step - loss: 0.3887 - acc: 0.8194 - val_loss: 0.4501 - val_acc: 0.7938
    Epoch 73/100
    100/100 [==============================] - 33s 326ms/step - loss: 0.3777 - acc: 0.8284 - val_loss: 0.5260 - val_acc: 0.7790
    Epoch 74/100
    100/100 [==============================] - 32s 325ms/step - loss: 0.3753 - acc: 0.8384 - val_loss: 0.4243 - val_acc: 0.8039
    Epoch 75/100
    100/100 [==============================] - 33s 326ms/step - loss: 0.3870 - acc: 0.8278 - val_loss: 0.4143 - val_acc: 0.8086
    Epoch 76/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.3773 - acc: 0.8366 - val_loss: 0.4166 - val_acc: 0.8192
    Epoch 77/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.3706 - acc: 0.8294 - val_loss: 0.4616 - val_acc: 0.8054
    Epoch 78/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.3649 - acc: 0.8300 - val_loss: 0.4047 - val_acc: 0.8204
    Epoch 79/100
    100/100 [==============================] - 33s 331ms/step - loss: 0.3617 - acc: 0.8378 - val_loss: 0.4001 - val_acc: 0.8338
    Epoch 80/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.3696 - acc: 0.8337 - val_loss: 0.4469 - val_acc: 0.7945
    Epoch 81/100
    100/100 [==============================] - 32s 321ms/step - loss: 0.3562 - acc: 0.8419 - val_loss: 0.4342 - val_acc: 0.8096
    Epoch 82/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.3619 - acc: 0.8366 - val_loss: 0.4344 - val_acc: 0.8138
    Epoch 83/100
    100/100 [==============================] - 32s 323ms/step - loss: 0.3725 - acc: 0.8284 - val_loss: 0.5361 - val_acc: 0.7900
    Epoch 84/100
    100/100 [==============================] - 33s 329ms/step - loss: 0.3488 - acc: 0.8453 - val_loss: 0.4690 - val_acc: 0.7784
    Epoch 85/100
    100/100 [==============================] - 32s 325ms/step - loss: 0.3583 - acc: 0.8409 - val_loss: 0.4496 - val_acc: 0.7893
    Epoch 86/100
    100/100 [==============================] - 33s 330ms/step - loss: 0.3629 - acc: 0.8391 - val_loss: 0.3936 - val_acc: 0.8318
    Epoch 87/100
    100/100 [==============================] - 33s 329ms/step - loss: 0.3465 - acc: 0.8459 - val_loss: 0.4205 - val_acc: 0.8154
    Epoch 88/100
    100/100 [==============================] - 33s 333ms/step - loss: 0.3403 - acc: 0.8544 - val_loss: 0.5666 - val_acc: 0.7919
    Epoch 89/100
    100/100 [==============================] - 33s 331ms/step - loss: 0.3578 - acc: 0.8375 - val_loss: 0.3980 - val_acc: 0.8331
    Epoch 90/100
    100/100 [==============================] - 32s 322ms/step - loss: 0.3565 - acc: 0.8434 - val_loss: 0.4294 - val_acc: 0.8166
    Epoch 91/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.3343 - acc: 0.8453 - val_loss: 0.4239 - val_acc: 0.8235
    Epoch 92/100
    100/100 [==============================] - 32s 325ms/step - loss: 0.3484 - acc: 0.8500 - val_loss: 0.5225 - val_acc: 0.7811
    Epoch 93/100
    100/100 [==============================] - 33s 326ms/step - loss: 0.3523 - acc: 0.8425 - val_loss: 0.4181 - val_acc: 0.8293
    Epoch 94/100
    100/100 [==============================] - 33s 330ms/step - loss: 0.3390 - acc: 0.8466 - val_loss: 0.5930 - val_acc: 0.7646
    Epoch 95/100
    100/100 [==============================] - 33s 327ms/step - loss: 0.3414 - acc: 0.8484 - val_loss: 0.4632 - val_acc: 0.7977
    Epoch 96/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.3295 - acc: 0.8537 - val_loss: 0.4123 - val_acc: 0.8164
    Epoch 97/100
    100/100 [==============================] - 32s 324ms/step - loss: 0.3344 - acc: 0.8581 - val_loss: 0.3890 - val_acc: 0.8249
    Epoch 98/100
    100/100 [==============================] - 33s 328ms/step - loss: 0.3204 - acc: 0.8609 - val_loss: 0.4758 - val_acc: 0.8293
    Epoch 99/100
    100/100 [==============================] - 33s 326ms/step - loss: 0.3218 - acc: 0.8591 - val_loss: 0.5690 - val_acc: 0.7500
    Epoch 100/100
    100/100 [==============================] - 33s 330ms/step - loss: 0.3291 - acc: 0.8587 - val_loss: 0.3975 - val_acc: 0.8247
    --- 3310.1647398471832 seconds ---



```python
print("Run time:", round(3165.070887565613/60, 2), "minutes.")
```

    Run time: 52.75 minutes.


Let's save our model -- we will be using it in the section on convnet visualization.


```python
model.save('cats_and_dogs_small_2_1stlayer64.h5')
```


```python
#!cp cats_and_dogs_small_2.h5 cats_and_dogs_small_2_1stlayer64.h5
```

___

## Visualization part from 5.4.2:


```python
from keras import backend as K
import numpy as np
import tensorflow as tf
```


```python
model.summary()
```

    Model: "sequential_9"
    _________________________________________________________________
    Layer (type)                 Output Shape              Param #   
    =================================================================
    conv2d_33 (Conv2D)           (None, 148, 148, 64)      1792      
    _________________________________________________________________
    max_pooling2d_33 (MaxPooling (None, 74, 74, 64)        0         
    _________________________________________________________________
    conv2d_34 (Conv2D)           (None, 72, 72, 64)        36928     
    _________________________________________________________________
    max_pooling2d_34 (MaxPooling (None, 36, 36, 64)        0         
    _________________________________________________________________
    conv2d_35 (Conv2D)           (None, 34, 34, 128)       73856     
    _________________________________________________________________
    max_pooling2d_35 (MaxPooling (None, 17, 17, 128)       0         
    _________________________________________________________________
    conv2d_36 (Conv2D)           (None, 15, 15, 128)       147584    
    _________________________________________________________________
    max_pooling2d_36 (MaxPooling (None, 7, 7, 128)         0         
    _________________________________________________________________
    flatten_9 (Flatten)          (None, 6272)              0         
    _________________________________________________________________
    dropout_7 (Dropout)          (None, 6272)              0         
    _________________________________________________________________
    dense_17 (Dense)             (None, 512)               3211776   
    _________________________________________________________________
    dense_18 (Dense)             (None, 1)                 513       
    =================================================================
    Total params: 3,472,449
    Trainable params: 3,472,449
    Non-trainable params: 0
    _________________________________________________________________



```python
def deprocess_image(x):
    # normalize tensor: center on 0., ensure std is 0.1
    x -= x.mean()
    x /= (x.std() + 1e-5)
    x *= 0.1

    # clip to [0, 1]
    x += 0.5
    x = np.clip(x, 0, 1)

    # convert to RGB array
    x *= 255
    x = np.clip(x, 0, 255).astype('uint8')
    return x
```


```python
def generate_pattern(layer_name, filter_index, size=150):
    # Build a loss function that maximizes the activation
    # of the nth filter of the layer considered.
    layer_output = model.get_layer(layer_name).output
    loss = K.mean(layer_output[:, :, :, filter_index])

    # Compute the gradient of the input picture wrt this loss
    grads = K.gradients(loss, model.input)[0]

    # Normalization trick: we normalize the gradient
    grads /= (K.sqrt(K.mean(K.square(grads))) + 1e-5)

    # This function returns the loss and grads given the input picture
    iterate = K.function([model.input], [loss, grads])
    
    # We start from a gray image with some noise
    input_img_data = np.random.random((1, size, size, 3)) * 20 + 128.

    # Run gradient ascent for 40 steps
    step = 1.
    for i in range(40):
        loss_value, grads_value = iterate([input_img_data])
        input_img_data += grads_value * step
        
    img = input_img_data[0]
    return deprocess_image(img)
```


```python
import matplotlib.pyplot as plt
plt.imshow(generate_pattern(model.layers[7].name, 127))
plt.show()
```


![png](output_57_0.png)



```python
layer_names = []
for layer in model.layers:
    layer_names.append(layer.name)
```


```python
layer_sizes = []
for layer in model.layers:
    layer_sizes.append(layer.output_shape[-1])
```


```python
layer_sizes
```




    [64, 64, 64, 64, 128, 128, 128, 128, 6272, 6272, 512, 1]




```python
start_time = time.time()

# This a empty (black) image where we will store our results.

# results = np.zeros((8 * size + 7 * margin, 8 * size + 7 * margin, 3)) 
# First input corresponds to the first loop and defines the length of the plot
# Second input corresponds to second loop and defines the width of the plot
# The order stays the same, when the length is cut

for index in [0, 1, 2, 3, 4, 5, 6, 7]: # the indices of the layers that should be printed and saved!!
    
    layer_name = layer_names[index]
    size = layer_sizes[index]
    length = int(size/8)
    margin = 5
    results = np.zeros((length * size + (length-1) * margin, 8 * size + 7 * margin, 3)) 
    # First input corresponds to the first loop and defines the length of the plot
    # Second input corresponds to second loop and defines the width of the plot
    # The order stays the same, when the length is cut


    for i in range(length):  # iterate over the rows of our results grid
        for j in range(8):  # iterate over the columns of our results grid
            # Generate the pattern for filter `i + (j * 8)` in `layer_name`
            filter_img = generate_pattern(layer_name, i + (j * 8), size=size)
            #print(i)
            #print(j)
            #print("__")
            # Put the result in the square `(i, j)` of the results grid
            horizontal_start = i * size + i * margin
            horizontal_end = horizontal_start + size
            vertical_start = j * size + j * margin
            vertical_end = vertical_start + size
            results[horizontal_start : horizontal_end, vertical_start : vertical_end, :] = filter_img

    # Display the results grid
    multiplier = int(size/64) # using the multiplier makes sure that the plot is shown optimally 
    plt.figure(figsize=(20, multiplier*20)) # (width, height)
    plt.imshow(results.astype('uint8'))
    plt.show()
    plt.savefig(layer_name + '_visualization.pdf'); # saves the figure
    
print("--- %s seconds ---" % (time.time() - start_time))
```


![png](output_61_0.png)



    <Figure size 432x288 with 0 Axes>



![png](output_61_2.png)



    <Figure size 432x288 with 0 Axes>



![png](output_61_4.png)



    <Figure size 432x288 with 0 Axes>



![png](output_61_6.png)



    <Figure size 432x288 with 0 Axes>



![png](output_61_8.png)



    <Figure size 432x288 with 0 Axes>



![png](output_61_10.png)



    <Figure size 432x288 with 0 Axes>



![png](output_61_12.png)



    <Figure size 432x288 with 0 Axes>



![png](output_61_14.png)


    --- 6278.773175239563 seconds ---



    <Figure size 432x288 with 0 Axes>



```python
print("Plotting and saving the main 8 Layers from Model 2 took", round(6278.773175239563/60, 2), "minutes.")
```

    Plotting and saving the main 8 Layers from Model 2 took 104.65 minutes.


# Putting all Functions together:

__Generate Pattern, generate Train & Valid Data, Predict (get Features), Flat Matrices, Accuracy, Feature Importance, Plots__

## Running on small Neural Network 


```python
from keras.models import load_model
```


```python
model = load_model('cats_and_dogs_small_2_1stlayer32.h5')
```


```python
from keras import models

# Extracts the outputs of the top 8 layers:
layer_outputs = [layer.output for layer in model.layers[:12]]
# Creates a model that will return these outputs, given the model input:
activation_model = models.Model(inputs=model.input, outputs=layer_outputs)
```


```python
model.summary()
```

    Model: "sequential_6"
    _________________________________________________________________
    Layer (type)                 Output Shape              Param #   
    =================================================================
    conv2d_21 (Conv2D)           (None, 148, 148, 32)      896       
    _________________________________________________________________
    max_pooling2d_21 (MaxPooling (None, 74, 74, 32)        0         
    _________________________________________________________________
    conv2d_22 (Conv2D)           (None, 72, 72, 64)        18496     
    _________________________________________________________________
    max_pooling2d_22 (MaxPooling (None, 36, 36, 64)        0         
    _________________________________________________________________
    conv2d_23 (Conv2D)           (None, 34, 34, 128)       73856     
    _________________________________________________________________
    max_pooling2d_23 (MaxPooling (None, 17, 17, 128)       0         
    _________________________________________________________________
    conv2d_24 (Conv2D)           (None, 15, 15, 128)       147584    
    _________________________________________________________________
    max_pooling2d_24 (MaxPooling (None, 7, 7, 128)         0         
    _________________________________________________________________
    flatten_6 (Flatten)          (None, 6272)              0         
    _________________________________________________________________
    dropout_5 (Dropout)          (None, 6272)              0         
    _________________________________________________________________
    dense_11 (Dense)             (None, 512)               3211776   
    _________________________________________________________________
    dense_12 (Dense)             (None, 1)                 513       
    =================================================================
    Total params: 3,453,121
    Trainable params: 3,453,121
    Non-trainable params: 0
    _________________________________________________________________



```python
activation_model.summary()
```

    Model: "model_1"
    _________________________________________________________________
    Layer (type)                 Output Shape              Param #   
    =================================================================
    conv2d_21_input (InputLayer) (None, 150, 150, 3)       0         
    _________________________________________________________________
    conv2d_21 (Conv2D)           (None, 148, 148, 32)      896       
    _________________________________________________________________
    max_pooling2d_21 (MaxPooling (None, 74, 74, 32)        0         
    _________________________________________________________________
    conv2d_22 (Conv2D)           (None, 72, 72, 64)        18496     
    _________________________________________________________________
    max_pooling2d_22 (MaxPooling (None, 36, 36, 64)        0         
    _________________________________________________________________
    conv2d_23 (Conv2D)           (None, 34, 34, 128)       73856     
    _________________________________________________________________
    max_pooling2d_23 (MaxPooling (None, 17, 17, 128)       0         
    _________________________________________________________________
    conv2d_24 (Conv2D)           (None, 15, 15, 128)       147584    
    _________________________________________________________________
    max_pooling2d_24 (MaxPooling (None, 7, 7, 128)         0         
    _________________________________________________________________
    flatten_6 (Flatten)          (None, 6272)              0         
    _________________________________________________________________
    dropout_5 (Dropout)          (None, 6272)              0         
    _________________________________________________________________
    dense_11 (Dense)             (None, 512)               3211776   
    _________________________________________________________________
    dense_12 (Dense)             (None, 1)                 513       
    =================================================================
    Total params: 3,453,121
    Trainable params: 3,453,121
    Non-trainable params: 0
    _________________________________________________________________



```python
activation_model.output_shape
```




    [(None, 148, 148, 32),
     (None, 74, 74, 32),
     (None, 72, 72, 64),
     (None, 36, 36, 64),
     (None, 34, 34, 128),
     (None, 17, 17, 128),
     (None, 15, 15, 128),
     (None, 7, 7, 128),
     (None, 6272),
     (None, 6272),
     (None, 512),
     (None, 1)]




```python
import functools
from operator import mul

from keras.preprocessing import image
from keras.preprocessing.image import ImageDataGenerator

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

import time

import lightgbm as lgb
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix

from keras import backend as K
```


```python
layer_sizes = []
for layer in activation_model.layers:
    layer_sizes.append(layer.output_shape[1:])
```


```python
layer_names = []
for layer in activation_model.layers:
    layer_names.append(layer.name)
```


```python
# Chollet Function 

def deprocess_image(x):
    # normalize tensor: center on 0., ensure std is 0.1
    x -= x.mean()
    x /= (x.std() + 1e-5)
    x *= 0.1

    # clip to [0, 1]
    x += 0.5
    x = np.clip(x, 0, 1)

    # convert to RGB array
    x *= 255
    x = np.clip(x, 0, 255).astype('uint8')
    return x
```


```python
# Chollet Function

def generate_pattern(model, layer_name, filter_index, size=150):
    # Build a loss function that maximizes the activation
    # of the nth filter of the layer considered.
    layer_output = model.get_layer(layer_name).output
    loss = K.mean(layer_output[:, :, :, filter_index])

    # Compute the gradient of the input picture wrt this loss
    grads = K.gradients(loss, model.input)[0]

    # Normalization trick: we normalize the gradient
    grads /= (K.sqrt(K.mean(K.square(grads))) + 1e-5)

    # This function returns the loss and grads given the input picture
    iterate = K.function([model.input], [loss, grads])
    
    # We start from a gray image with some noise
    input_img_data = np.random.random((1, size, size, 3)) * 20 + 128.

    # Run gradient ascent for 40 steps
    step = 1.
    for i in range(40):
        loss_value, grads_value = iterate([input_img_data])
        input_img_data += grads_value * step
        
    img = input_img_data[0]
    return deprocess_image(img)
```


```python
# Function No. 1

def gen_train_valid_data():
    # Training part 
    from keras.preprocessing import image
    
    datagen = ImageDataGenerator(
      rotation_range=40,
      width_shift_range=0.2,
      height_shift_range=0.2,
      shear_range=0.2,
      zoom_range=0.2,
      horizontal_flip=True,
      fill_mode='nearest')
    
    all_augmented_pictures = []
    for animal in ['cat', 'dog']:
        for i in range(1000): # number of cats pictures in the following folder
            # For Local Server 
            #img_path = '/Users/Nik/Documents/CodeAndStats/deep-learning-with-python-notebooks-master-2/train/' + animal +'s/' + animal + '.' + str(i) + '.jpg'
            # For Plato Server 
            img_path = '/home/loecher/data/cats_and_dogs/train/' + animal +'s/' + animal + '.' + str(i) + '.jpg'
            
            # Read the image and resize it
            img = image.load_img(img_path, target_size=(150, 150))
            
            # Convert it to a Numpy array with shape (150, 150, 3)
            x = image.img_to_array(img)

            # Reshape it to (1, 150, 150, 3)
            x = x.reshape((1,) + x.shape)
            
            # The .flow() command below generates batches of randomly transformed images.
            # It will loop indefinitely, so we need to `break` the loop at some point!
            i = 0
            for batch in datagen.flow(x, batch_size=1):
                #plt.figure(i)
                #imgplot = plt.imshow(image.array_to_img(batch[0]))
                #all_augmented_pictures.append(batch[0]/255.) # NOTE: probably has to be resized
                all_augmented_pictures.append(np.expand_dims(image.array_to_img(batch[0]), axis = 0)/255.)
                i += 1
                if i % 4 == 0: # Number of pictures printed
                    break

    # Validation part 
    validation_pictures = []

    for animal in ['cat', 'dog']:
        for i in range(1000,1500): # number of cats pictures in the following folder
            # For Local Server # 
            #img_path = '/Users/Nik/Documents/CodeAndStats/deep-learning-with-python-notebooks-master-2/validation/' + animal +'s/' + animal + '.' + str(i) + '.jpg'
            # For Plato Server 
            img_path = '/home/loecher/data/cats_and_dogs/validation/' + animal +'s/' + animal + '.' + str(i) + '.jpg'
            # This is module with image preprocessing utilities
            from keras.preprocessing import image

            # Read the image and resize it
            img = image.load_img(img_path, target_size=(150, 150))

            # Convert it to a Numpy array with shape (150, 150, 3)
            x = image.img_to_array(img)

            # Reshape it to (1, 150, 150, 3)
            x = x.reshape((1,) + x.shape)

            x /= 255.

            validation_pictures.append(x)
            
    return(all_augmented_pictures, validation_pictures)
```


```python
# Function No. 2
def flat_matrices(model, index, train_img, validation_img):
    
    # size = functools.reduce(mul, layer_sizes[index])
    #training 
    flattened_matrix = []
    for i in range(len(train_img)):
        predicts_train = model.predict(train_img[i])[index]
        predicts_train_shape = functools.reduce(mul, predicts_train.shape)
        flattened_matrix.append(np.reshape(predicts_train, predicts_train_shape))
    flattened_matrix_np = np.vstack(flattened_matrix)

    #validation
    flattened_matrix_valid = []
    for i in range(len(validation_img)):
        predicts_valid = model.predict(validation_img[i])[index]
        predicts_valid_shape = functools.reduce(mul, predicts_valid.shape)
        flattened_matrix_valid.append(np.reshape(predicts_valid, predicts_valid_shape))
    flattened_matrix_valid_np = np.vstack(flattened_matrix_valid)
    
    # cats are 0 
    # dogs are 1
    train_labels = [0] * 4000 + [1] * 4000
    
    # cats are 0 
    # dogs are 1
    validation_labels = [0] * 500 + [1] * 500
    
    layer_shape_output = model.layers[index].output_shape
    
    print("Layer name:", model.layers[index].name)
    print("Output shape:", model.layers[index].output_shape)
    return(flattened_matrix_np, flattened_matrix_valid_np, train_labels, validation_labels, layer_shape_output)
```


```python
# Function No. 3
def acc_and_features(iterations, train, validation, validations_labels, train_label, layer_shapes, l_rate = 0.05, depth = 4, n_features = 100):
    
    d_train = lgb.Dataset(train, label = train_label)
    
    # parameter 
    params = {}
    params['learning_rate'] = l_rate
    params['boosting_type'] = 'gbdt'
    params['objective'] = 'binary'
    params['metric'] = 'binary_logloss'
    params['sub_feature'] = 1 # keep at 1 for Boosting only
    params['num_leaves'] = 10
    params['min_data'] = 50
    params['max_depth'] = depth
    #params['max_bin'] = 10
    params['bagging_fraction'] = 0.25
    
    clf = lgb.train(params, d_train, iterations) # trains
    
    y_pred = clf.predict(validation) # predicts
    
    top_n_features = clf.feature_importance("gain").argsort()[-n_features:][::-1] # returns top n features positions
    top_n_dimensions = top_n_features % layer_shapes[-1] 
    unique, counts = np.unique(top_n_dimensions, return_counts=True)
    top_n_dimensions_df = pd.DataFrame({'label': unique, 'Counts': counts}).sort_values("Counts", ascending=False)
     
    print("Training shape:", train.shape)
    print("The accuracy is:", accuracy_score(np.round(y_pred), validations_labels))
    return(top_n_features, top_n_dimensions, top_n_dimensions_df)
```


```python
def plot_dimensions(model, top_dimensions, index = 8):
    w = 5
    h = 5
    fig = plt.figure(figsize=(20, 20))
    columns = 5
    rows = 5

    # ax enables access to manipulate each of subplots
    ax = []
    cols = int(len(top_dimensions)/10)
    # for i in range(columns*rows):
    for i in range(len(top_dimensions)):
        # create subplot and append to ax
        #ax.append(fig.add_subplot(rows, columns, i+1))
        ax.append(fig.add_subplot(10, cols, i+1))
        ax[-1].set_title("Dimension:" + str(top_dimensions[i]))  # set title
        ax[-1].set_yticklabels([])
        ax[-1].set_xticklabels([])
        ax[-1].set_xticks([])
        ax[-1].set_xticks([])
        plt.imshow(generate_pattern(model, model.layers[index].name, top_dimensions[i]))

    #ax[2].plot(xs, 3*ys)
    #ax[19].plot(ys**2, xs)

    plt.show()  # finally, render the plot
```


```python

```


```python
def run_all(model, index = 8, iteration = 1000, features = 100):
    all_augmented_pictures, validation_pictures = gen_train_valid_data()
    train_matrices, validation_matrices, train_labels, valid_labels, layer_shape = flat_matrices(model, index, all_augmented_pictures, validation_pictures)
    top_features, top_dimensions, top_dim_counts = acc_and_features(iterations = iteration, 
                                                            train = train_matrices, 
                                                            validation = validation_matrices, 
                                                            validations_labels = valid_labels,
                                                            train_label = train_labels,
                                                            layer_shapes = layer_shape,
                                                            depth = 4,
                                                            n_features = features)
    plot_dimensions(model, top_dimensions = top_dimensions, index = index)
```


```python
run_all(1, 1000, 100)
```

    Layer name: conv2d_21
    Output shape: (None, 148, 148, 32)
    Training shape: (8000, 175232)
    The accuracy is: 0.682



![png](output_83_1.png)



```python
run_all(5, 1000, 100)
```

    Layer name: conv2d_23
    Output shape: (None, 34, 34, 128)
    Training shape: (8000, 36992)
    The accuracy is: 0.762



![png](output_84_1.png)



```python
run_all(6, 1000, 100)
```

    Layer name: max_pooling2d_23
    Output shape: (None, 17, 17, 128)
    Training shape: (8000, 28800)
    The accuracy is: 0.795



![png](output_85_1.png)



```python
# 0.823
run_all(activation_model, 8, 1000, 100)
```

    Layer name: max_pooling2d_24
    Output shape: (None, 7, 7, 128)
    Training shape: (8000, 6272)
    The accuracy is: 0.814



![png](output_86_1.png)



```python
# NEW NEW NEW
# 0.823
run_all(activation_model, 8, 1000, 100)
```

    Layer name: max_pooling2d_24
    Output shape: (None, 7, 7, 128)
    Training shape: (8000, 6272)
    The accuracy is: 0.814



![png](output_87_1.png)



```python

```


```python
start_time = time.time()

all_augmented_pictures, validation_pictures = gen_train_valid_data()
train_matrices, validation_matrices, train_labels, valid_labels, layer_shape = flat_matrices(activation_model_large, 11, all_augmented_pictures, validation_pictures)
top_features, top_dimensions, top_dim_counts = acc_and_features(iterations = 10, 
                                                            train = train_matrices, 
                                                            validation = validation_matrices, 
                                                            validations_labels = valid_labels,
                                                            train_label = train_labels,
                                                            layer_shapes = layer_shape,
                                                            depth = 4,
                                                            n_features = 10)
plot_dimensions(activation_model_large, top_dimensions, index = 11)

print("--- %s seconds ---" % (time.time() - start_time))
```

    Layer name: block4_conv1
    Output shape: (None, 18, 18, 512)
    Training shape: (8000, 165888)
    The accuracy is: 0.732



![png](output_89_1.png)


    --- 551.5714266300201 seconds ---



```python

```

## Call Python Function 


```python
%run CNN-plot.py
```

    Layer name: block4_conv1
    Output shape: (None, 18, 18, 512)
    Training shape: (8000, 165888)
    The accuracy is: 0.695



![png](output_92_1.png)


    --- 552.6282608509064 seconds ---



```python

```

### Layer 11, Large Neural Network:


```python
start_time = time.time()

all_augmented_pictures, validation_pictures = gen_train_valid_data()

print("--- %s seconds ---" % (time.time() - start_time))
```

    --- 42.851104497909546 seconds ---



```python
start_time = time.time()

train_matrices, validation_matrices, train_labels, valid_labels, layer_shape = flat_matrices(activation_model_large, 11, all_augmented_pictures, validation_pictures)

print("--- %s seconds ---" % (time.time() - start_time))
```

    Layer name: block4_conv1
    Output shape: (None, 18, 18, 512)
    --- 302.0625202655792 seconds ---



```python
start_time = time.time()

top_features, top_dimensions, top_dim_counts = acc_and_features(iterations = 1000, 
                                                            train = train_matrices, 
                                                            validation = validation_matrices, 
                                                            validations_labels = valid_labels,
                                                            train_label = train_labels,
                                                            layer_shapes = layer_shape,
                                                            depth = 4,
                                                            n_features = 100)

print("--- %s seconds ---" % (time.time() - start_time))
```

    Training shape: (8000, 165888)
    The accuracy is: 0.865
    --- 1041.1322185993195 seconds ---



```python
top_dimensions
```




    array([404, 319, 251, 404, 403, 167, 404, 436,  25, 403, 159, 205, 155,
           134, 356,  29, 251, 452,  72, 356, 297, 403, 165, 152, 167,  65,
            72, 356, 205, 347, 476,  17, 251, 375, 353, 109, 251, 216, 155,
           428, 134, 501,  17,  72, 404, 250, 356, 216, 134, 251, 347,  17,
            73, 303, 403,  92, 167, 140, 251, 404, 471, 155, 404, 404, 251,
           203,  14, 319, 134, 216, 134, 136, 403,  17, 316, 404, 423, 251,
           413, 155, 399, 167, 468, 356,  80, 356, 316, 356, 371, 216, 477,
           124, 503, 423, 347, 338, 347, 303,  22, 403])




```python
start_time = time.time()

import matplotlib.pyplot as plt
plt.imshow(generate_pattern(activation_model_large, activation_model_large.layers[11].name, top_dimensions[2]))
print("The max. Dimension for this Layer is:", layer_shape[-1])
print("The name of the Layer is:", activation_model_large.layers[11].name)
plt.show()

print("--- %s seconds ---" % (time.time() - start_time))
```

    The max. Dimension for this Layer is: 512
    The name of the Layer is: block4_conv1



![png](output_99_1.png)


    --- 2.999497175216675 seconds ---



```python
start_time = time.time()

plot_dimensions(activation_model_large, top_dimensions, index = 11)

print("--- %s seconds ---" % (time.time() - start_time))
```


![png](output_100_0.png)


    --- 311.4335241317749 seconds ---


### Layer 1, Large Neural Network:


```python
start_time = time.time()

all_augmented_pictures, validation_pictures = gen_train_valid_data()

print("--- %s seconds ---" % (time.time() - start_time))
```

    --- 43.56447434425354 seconds ---



```python
start_time = time.time()

train_matrices, validation_matrices, train_labels, valid_labels, layer_shape = flat_matrices(activation_model_large, 1, all_augmented_pictures, validation_pictures)

print("--- %s seconds ---" % (time.time() - start_time))
```

    Layer name: block1_conv1
    Output shape: (None, 150, 150, 64)
    --- 323.7565836906433 seconds ---



```python
layer_shape
```




    (None, 150, 150, 64)




```python
start_time = time.time()

top_features, top_dimensions, top_dim_counts = acc_and_features(iterations = 1000, 
                                                            train = train_matrices, 
                                                            validation = validation_matrices, 
                                                            validations_labels = valid_labels,
                                                            train_label = train_labels,
                                                            layer_shapes = layer_shape,
                                                            depth = 4,
                                                            n_features = 10)

print("--- %s seconds ---" % (time.time() - start_time))
```


```python
top_dimensions
```


```python
start_time = time.time()

import matplotlib.pyplot as plt
plt.imshow(generate_pattern(activation_model_large, activation_model_large.layers[1].name, 1))
print("The max. Dimension for this Layer is:", layer_shape[-1])
print("The name of the Layer is:", activation_model_large.layers[1].name)
plt.show()

print("--- %s seconds ---" % (time.time() - start_time))
```

    The max. Dimension for this Layer is: 64
    The name of the Layer is: block1_conv1



![png](output_107_1.png)


    --- 0.4292943477630615 seconds ---



```python
hundred_dims = np.arange(0,60)
```


```python
start_time = time.time()

plot_dimensions(activation_model_large, hundred_dims, index = 1)

print("--- %s seconds ---" % (time.time() - start_time))
```


![png](output_109_0.png)


    --- 36.11064791679382 seconds ---



```python

```


```python

```

## Running on large Neural Network


```python
from keras.applications import VGG16
from keras import backend as K
import time

model_large = VGG16(weights='imagenet',
              include_top=False,
             input_shape=(150, 150, 3))

# layer_name = 'block3_conv1'
# filter_index = 0

# layer_output = model.get_layer(layer_name).output
# loss = K.mean(layer_output[:, :, :, filter_index])
```


```python
model_large.summary()
```

    Model: "vgg16"
    _________________________________________________________________
    Layer (type)                 Output Shape              Param #   
    =================================================================
    input_1 (InputLayer)         (None, 150, 150, 3)       0         
    _________________________________________________________________
    block1_conv1 (Conv2D)        (None, 150, 150, 64)      1792      
    _________________________________________________________________
    block1_conv2 (Conv2D)        (None, 150, 150, 64)      36928     
    _________________________________________________________________
    block1_pool (MaxPooling2D)   (None, 75, 75, 64)        0         
    _________________________________________________________________
    block2_conv1 (Conv2D)        (None, 75, 75, 128)       73856     
    _________________________________________________________________
    block2_conv2 (Conv2D)        (None, 75, 75, 128)       147584    
    _________________________________________________________________
    block2_pool (MaxPooling2D)   (None, 37, 37, 128)       0         
    _________________________________________________________________
    block3_conv1 (Conv2D)        (None, 37, 37, 256)       295168    
    _________________________________________________________________
    block3_conv2 (Conv2D)        (None, 37, 37, 256)       590080    
    _________________________________________________________________
    block3_conv3 (Conv2D)        (None, 37, 37, 256)       590080    
    _________________________________________________________________
    block3_pool (MaxPooling2D)   (None, 18, 18, 256)       0         
    _________________________________________________________________
    block4_conv1 (Conv2D)        (None, 18, 18, 512)       1180160   
    _________________________________________________________________
    block4_conv2 (Conv2D)        (None, 18, 18, 512)       2359808   
    _________________________________________________________________
    block4_conv3 (Conv2D)        (None, 18, 18, 512)       2359808   
    _________________________________________________________________
    block4_pool (MaxPooling2D)   (None, 9, 9, 512)         0         
    _________________________________________________________________
    block5_conv1 (Conv2D)        (None, 9, 9, 512)         2359808   
    _________________________________________________________________
    block5_conv2 (Conv2D)        (None, 9, 9, 512)         2359808   
    _________________________________________________________________
    block5_conv3 (Conv2D)        (None, 9, 9, 512)         2359808   
    _________________________________________________________________
    block5_pool (MaxPooling2D)   (None, 4, 4, 512)         0         
    =================================================================
    Total params: 14,714,688
    Trainable params: 14,714,688
    Non-trainable params: 0
    _________________________________________________________________



```python
from keras import models

# Extracts the outputs of the top 8 layers:
layer_outputs_large = [layer.output for layer in model_large.layers[:16]]
# Creates a model that will return these outputs, given the model input:
activation_model_large = models.Model(inputs = model_large.input, outputs = layer_outputs_large[1:]) # skip input layer
```


```python
layer_sizes_large = []
for layer in activation_model_large.layers:
    layer_sizes_large.append(layer.output_shape[1:])
layer_names_large = []
for layer in activation_model_large.layers:
    layer_names_large.append(layer.name)
```


```python
activation_model_large.summary()
```

    Model: "model_2"
    _________________________________________________________________
    Layer (type)                 Output Shape              Param #   
    =================================================================
    input_1 (InputLayer)         (None, 150, 150, 3)       0         
    _________________________________________________________________
    block1_conv1 (Conv2D)        (None, 150, 150, 64)      1792      
    _________________________________________________________________
    block1_conv2 (Conv2D)        (None, 150, 150, 64)      36928     
    _________________________________________________________________
    block1_pool (MaxPooling2D)   (None, 75, 75, 64)        0         
    _________________________________________________________________
    block2_conv1 (Conv2D)        (None, 75, 75, 128)       73856     
    _________________________________________________________________
    block2_conv2 (Conv2D)        (None, 75, 75, 128)       147584    
    _________________________________________________________________
    block2_pool (MaxPooling2D)   (None, 37, 37, 128)       0         
    _________________________________________________________________
    block3_conv1 (Conv2D)        (None, 37, 37, 256)       295168    
    _________________________________________________________________
    block3_conv2 (Conv2D)        (None, 37, 37, 256)       590080    
    _________________________________________________________________
    block3_conv3 (Conv2D)        (None, 37, 37, 256)       590080    
    _________________________________________________________________
    block3_pool (MaxPooling2D)   (None, 18, 18, 256)       0         
    _________________________________________________________________
    block4_conv1 (Conv2D)        (None, 18, 18, 512)       1180160   
    _________________________________________________________________
    block4_conv2 (Conv2D)        (None, 18, 18, 512)       2359808   
    _________________________________________________________________
    block4_conv3 (Conv2D)        (None, 18, 18, 512)       2359808   
    _________________________________________________________________
    block4_pool (MaxPooling2D)   (None, 9, 9, 512)         0         
    _________________________________________________________________
    block5_conv1 (Conv2D)        (None, 9, 9, 512)         2359808   
    =================================================================
    Total params: 9,995,072
    Trainable params: 9,995,072
    Non-trainable params: 0
    _________________________________________________________________



```python
layer_names_large
```




    ['input_1',
     'block1_conv1',
     'block1_conv2',
     'block1_pool',
     'block2_conv1',
     'block2_conv2',
     'block2_pool',
     'block3_conv1',
     'block3_conv2',
     'block3_conv3',
     'block3_pool',
     'block4_conv1',
     'block4_conv2',
     'block4_conv3',
     'block4_pool',
     'block5_conv1']




```python

```


```python
start_time = time.time()

run_all(activation_model_large, 11, 1000, 100)

print("--- %s seconds ---" % (time.time() - start_time))
```

    Layer name: block4_conv1
    Output shape: (None, 18, 18, 512)
    Training shape: (8000, 165888)
    The accuracy is: 0.847



```python

```


```python

```

___

Let's plot our results again:


```python
acc = history.history['acc']
val_acc = history.history['val_acc']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(len(acc))

plt.plot(epochs, acc, 'bo', label='Training acc')
plt.plot(epochs, val_acc, 'b', label='Validation acc')
plt.title('Training and validation accuracy')
plt.legend()

plt.figure()

plt.plot(epochs, loss, 'bo', label='Training loss')
plt.plot(epochs, val_loss, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.legend()

plt.show()
```

Thanks to data augmentation and dropout, we are no longer overfitting: the training curves are rather closely tracking the validation 
curves. We are now able to reach an accuracy of 82%, a 15% relative improvement over the non-regularized model.

By leveraging regularization techniques even further and by tuning the network's parameters (such as the number of filters per convolution 
layer, or the number of layers in the network), we may be able to get an even better accuracy, likely up to 86-87%. However, it would prove 
very difficult to go any higher just by training our own convnet from scratch, simply because we have so little data to work with. As a 
next step to improve our accuracy on this problem, we will have to leverage a pre-trained model, which will be the focus of the next two 
sections.
